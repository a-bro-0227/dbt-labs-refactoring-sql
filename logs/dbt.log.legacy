2022-04-21 01:12:11.942182 (MainThread): Running with dbt=1.0.4
2022-04-21 01:12:12.159779 (MainThread): running dbt with arguments Namespace(cls=<class 'dbt_rpc.task.server.RPCServerTask'>, debug=None, defer=None, exclude=None, fail_fast=None, host='0.0.0.0', log_cache_events=False, log_format=None, models=None, partial_parse=True, port=8580, printer_width=None, profile='user', profiles_dir='/usr/src/develop/.dbt', project_dir=None, record_timing_info=None, rpc_method=None, send_anonymous_usage_stats=None, single_threaded=False, state=None, static_parser=None, target=None, threads=None, use_colors=None, use_experimental_parser=None, vars='{}', version_check=None, warn_error=None, which='rpc', write_json=None)
2022-04-21 01:12:12.174109 (MainThread): Tracking: tracking
2022-04-21 01:12:12.174346 (MainThread): 01:12:12  Sending event: {'category': 'dbt', 'action': 'invocation', 'label': 'start', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6cb271b2e0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c6e3894f0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c6e3890a0>]}
2022-04-21 01:12:12.174628 (MainThread): Serving RPC server at 0.0.0.0:8580, pid=22
2022-04-21 01:12:12.174857 (MainThread): Supported methods: ['build', 'cli_args', 'compile', 'compile_sql', 'deps', 'docs.generate', 'gc', 'get-manifest', 'kill', 'list', 'poll', 'ps', 'run', 'run-operation', 'run_sql', 'seed', 'snapshot', 'snapshot-freshness', 'source-freshness', 'status', 'test']
2022-04-21 01:12:12.175009 (MainThread): Send requests to http://localhost:8580/jsonrpc
2022-04-21 01:12:12.177275 (Thread-12): 01:12:12  Partial parse save file not found. Starting full parse.
2022-04-21 01:12:12.177507 (Thread-12): 01:12:12  Sending event: {'category': 'dbt', 'action': 'partial_parser', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c6e393040>]}
2022-04-21 01:12:12.204569 (Thread-12): 01:12:12  Parsing macros/adapters.sql
2022-04-21 01:12:12.242666 (Thread-12): 01:12:12  Parsing macros/catalog.sql
2022-04-21 01:12:12.244523 (Thread-12): 01:12:12  Parsing macros/materializations/table.sql
2022-04-21 01:12:12.247531 (Thread-12): 01:12:12  Parsing macros/materializations/seed.sql
2022-04-21 01:12:12.252581 (Thread-12): 01:12:12  Parsing macros/materializations/incremental.sql
2022-04-21 01:12:12.260739 (Thread-12): 01:12:12  Parsing macros/materializations/merge.sql
2022-04-21 01:12:12.264413 (Thread-12): 01:12:12  Parsing macros/materializations/snapshot.sql
2022-04-21 01:12:12.265327 (Thread-12): 01:12:12  Parsing macros/materializations/view.sql
2022-04-21 01:12:12.266610 (Thread-12): 01:12:12  Parsing macros/adapters/metadata.sql
2022-04-21 01:12:12.273483 (Thread-12): 01:12:12  Parsing macros/adapters/columns.sql
2022-04-21 01:12:12.283023 (Thread-12): 01:12:12  Parsing macros/adapters/freshness.sql
2022-04-21 01:12:12.285805 (Thread-12): 01:12:12  Parsing macros/adapters/persist_docs.sql
2022-04-21 01:12:12.290040 (Thread-12): 01:12:12  Parsing macros/adapters/relation.sql
2022-04-21 01:12:12.299364 (Thread-12): 01:12:12  Parsing macros/adapters/schema.sql
2022-04-21 01:12:12.301446 (Thread-12): 01:12:12  Parsing macros/adapters/indexes.sql
2022-04-21 01:12:12.304097 (Thread-12): 01:12:12  Parsing macros/get_custom_name/get_custom_schema.sql
2022-04-21 01:12:12.306529 (Thread-12): 01:12:12  Parsing macros/get_custom_name/get_custom_alias.sql
2022-04-21 01:12:12.308005 (Thread-12): 01:12:12  Parsing macros/get_custom_name/get_custom_database.sql
2022-04-21 01:12:12.309551 (Thread-12): 01:12:12  Parsing macros/etc/datetime.sql
2022-04-21 01:12:12.317602 (Thread-12): 01:12:12  Parsing macros/etc/statement.sql
2022-04-21 01:12:12.321857 (Thread-12): 01:12:12  Parsing macros/generic_test_sql/unique.sql
2022-04-21 01:12:12.322545 (Thread-12): 01:12:12  Parsing macros/generic_test_sql/not_null.sql
2022-04-21 01:12:12.323125 (Thread-12): 01:12:12  Parsing macros/generic_test_sql/accepted_values.sql
2022-04-21 01:12:12.324458 (Thread-12): 01:12:12  Parsing macros/generic_test_sql/relationships.sql
2022-04-21 01:12:12.325304 (Thread-12): 01:12:12  Parsing macros/materializations/configs.sql
2022-04-21 01:12:12.327557 (Thread-12): 01:12:12  Parsing macros/materializations/hooks.sql
2022-04-21 01:12:12.331304 (Thread-12): 01:12:12  Parsing macros/materializations/models/table/table.sql
2022-04-21 01:12:12.338559 (Thread-12): 01:12:12  Parsing macros/materializations/models/table/create_table_as.sql
2022-04-21 01:12:12.341344 (Thread-12): 01:12:12  Parsing macros/materializations/models/view/create_or_replace_view.sql
2022-04-21 01:12:12.343964 (Thread-12): 01:12:12  Parsing macros/materializations/models/view/helpers.sql
2022-04-21 01:12:12.345232 (Thread-12): 01:12:12  Parsing macros/materializations/models/view/create_view_as.sql
2022-04-21 01:12:12.347482 (Thread-12): 01:12:12  Parsing macros/materializations/models/view/view.sql
2022-04-21 01:12:12.354364 (Thread-12): 01:12:12  Parsing macros/materializations/models/incremental/incremental.sql
2022-04-21 01:12:12.365798 (Thread-12): 01:12:12  Parsing macros/materializations/models/incremental/on_schema_change.sql
2022-04-21 01:12:12.380897 (Thread-12): 01:12:12  Parsing macros/materializations/models/incremental/is_incremental.sql
2022-04-21 01:12:12.382337 (Thread-12): 01:12:12  Parsing macros/materializations/models/incremental/merge.sql
2022-04-21 01:12:12.393301 (Thread-12): 01:12:12  Parsing macros/materializations/models/incremental/column_helpers.sql
2022-04-21 01:12:12.397575 (Thread-12): 01:12:12  Parsing macros/materializations/seeds/helpers.sql
2022-04-21 01:12:12.413440 (Thread-12): 01:12:12  Parsing macros/materializations/seeds/seed.sql
2022-04-21 01:12:12.419212 (Thread-12): 01:12:12  Parsing macros/materializations/tests/helpers.sql
2022-04-21 01:12:12.420931 (Thread-12): 01:12:12  Parsing macros/materializations/tests/test.sql
2022-04-21 01:12:12.425200 (Thread-12): 01:12:12  Parsing macros/materializations/tests/where_subquery.sql
2022-04-21 01:12:12.426934 (Thread-12): 01:12:12  Parsing macros/materializations/snapshots/helpers.sql
2022-04-21 01:12:12.437950 (Thread-12): 01:12:12  Parsing macros/materializations/snapshots/strategies.sql
2022-04-21 01:12:12.454207 (Thread-12): 01:12:12  Parsing macros/materializations/snapshots/snapshot_merge.sql
2022-04-21 01:12:12.455831 (Thread-12): 01:12:12  Parsing macros/materializations/snapshots/snapshot.sql
2022-04-21 01:12:12.467002 (Thread-12): 01:12:12  Parsing tests/generic/builtin.sql
2022-04-21 01:12:12.660078 (Thread-12): 01:12:12  1699: static parser successfully parsed example/my_second_dbt_model.sql
2022-04-21 01:12:12.672010 (Thread-12): 01:12:12  1699: static parser successfully parsed example/my_first_dbt_model.sql
2022-04-21 01:12:12.748784 (Thread-12): 01:12:12  Sending event: {'category': 'dbt', 'action': 'load_project', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f1d4610>]}
2022-04-21 01:12:13.226265 (Thread-13): handling status request
2022-04-21 01:12:13.226600 (Thread-13): 01:12:13  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c6c05b370>]}
2022-04-21 01:12:13.227573 (Thread-13): sending response (<Response 15565 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:12:13.231114 (Thread-14): handling status request
2022-04-21 01:12:13.231331 (Thread-14): 01:12:13  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c6e3891f0>]}
2022-04-21 01:12:13.232005 (Thread-14): sending response (<Response 15565 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:12:46.043423 (Thread-15): handling status request
2022-04-21 01:12:46.044982 (Thread-15): 01:12:46  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f1d4250>]}
2022-04-21 01:12:46.045809 (Thread-15): sending response (<Response 15565 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:12:48.555483 (Thread-16): 01:12:48  Partial parsing enabled: 0 files deleted, 0 files added, 0 files changed.
2022-04-21 01:12:48.555663 (Thread-16): 01:12:48  Partial parsing enabled, no changes found, skipping parsing
2022-04-21 01:12:48.560300 (Thread-16): 01:12:48  Sending event: {'category': 'dbt', 'action': 'load_project', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f16a550>]}
2022-04-21 01:12:49.249872 (Thread-17): handling status request
2022-04-21 01:12:49.250186 (Thread-17): 01:12:49  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f15ff70>]}
2022-04-21 01:12:49.250629 (Thread-17): sending response (<Response 1241 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:12:49.321475 (Thread-18): handling status request
2022-04-21 01:12:49.321693 (Thread-18): 01:12:49  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f15fe20>]}
2022-04-21 01:12:49.322033 (Thread-18): sending response (<Response 1241 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:19:15.622157 (Thread-19): 01:19:15  Partial parsing enabled: 0 files deleted, 0 files added, 0 files changed.
2022-04-21 01:19:15.623652 (Thread-19): 01:19:15  Partial parsing enabled, no changes found, skipping parsing
2022-04-21 01:19:15.628520 (Thread-19): 01:19:15  Sending event: {'category': 'dbt', 'action': 'load_project', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0eb6d0>]}
2022-04-21 01:19:16.390842 (Thread-20): handling status request
2022-04-21 01:19:16.391194 (Thread-20): 01:19:16  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f1ec6a0>]}
2022-04-21 01:19:16.391647 (Thread-20): sending response (<Response 1241 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:19:16.412436 (Thread-21): handling status request
2022-04-21 01:19:16.412657 (Thread-21): 01:19:16  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f1ec880>]}
2022-04-21 01:19:16.413030 (Thread-21): sending response (<Response 1241 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:19:42.385407 (Thread-22): 01:19:42  Partial parsing enabled: 0 files deleted, 0 files added, 0 files changed.
2022-04-21 01:19:42.387413 (Thread-22): 01:19:42  Partial parsing enabled, no changes found, skipping parsing
2022-04-21 01:19:42.393202 (Thread-22): 01:19:42  Sending event: {'category': 'dbt', 'action': 'load_project', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f1f8190>]}
2022-04-21 01:19:43.145106 (Thread-23): handling status request
2022-04-21 01:19:43.145506 (Thread-23): 01:19:43  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0e2640>]}
2022-04-21 01:19:43.145972 (Thread-23): sending response (<Response 1219 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:19:43.162260 (Thread-24): handling list request
2022-04-21 01:19:43.162482 (Thread-24): 01:19:43  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f16bf70>]}
2022-04-21 01:19:43.195535 (Thread-24): 01:19:43  Sending event: {'category': 'dbt', 'action': 'resource_counts', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f1d4a00>]}
2022-04-21 01:19:43.195801 (Thread-24): 01:19:43  Found 2 models, 4 tests, 0 snapshots, 0 analyses, 179 macros, 0 operations, 0 seed files, 0 sources, 0 exposures, 0 metrics
2022-04-21 01:19:43.198280 (Thread-24): 01:19:43  The selection criterion '+models/_archive/orginal_query+' does not match any nodes
2022-04-21 01:19:43.198421 (Thread-24): 01:19:43  No nodes selected!
2022-04-21 01:19:43.199915 (Thread-24): sending response (<Response 1942 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:19:43.293446 (Thread-25): handling status request
2022-04-21 01:19:43.293747 (Thread-25): 01:19:43  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c6d2c1ca0>]}
2022-04-21 01:19:43.294200 (Thread-25): sending response (<Response 1241 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:19:43.346730 (Thread-26): handling status request
2022-04-21 01:19:43.347015 (Thread-26): 01:19:43  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0e2400>]}
2022-04-21 01:19:43.347403 (Thread-26): sending response (<Response 1241 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:19:55.297357 (Thread-27): 01:19:55  Partial parsing enabled: 0 files deleted, 1 files added, 0 files changed.
2022-04-21 01:19:55.297674 (Thread-27): 01:19:55  Partial parsing: added file: my_new_project://models/_archive/orginal_query.sql
2022-04-21 01:19:55.301423 (Thread-27): 01:19:55  1699: static parser successfully parsed _archive/orginal_query.sql
2022-04-21 01:19:55.350152 (Thread-27): 01:19:55  Sending event: {'category': 'dbt', 'action': 'load_project', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0ae550>]}
2022-04-21 01:19:55.975294 (Thread-28): handling status request
2022-04-21 01:19:55.975616 (Thread-28): 01:19:55  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0ce790>]}
2022-04-21 01:19:55.976071 (Thread-28): sending response (<Response 1568 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:19:56.128076 (Thread-29): handling status request
2022-04-21 01:19:56.128392 (Thread-29): 01:19:56  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0ce5b0>]}
2022-04-21 01:19:56.128841 (Thread-29): sending response (<Response 1568 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:19:56.201329 (Thread-30): handling status request
2022-04-21 01:19:56.201569 (Thread-30): 01:19:56  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0ce430>]}
2022-04-21 01:19:56.201957 (Thread-30): sending response (<Response 1546 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:19:56.218702 (Thread-31): handling list request
2022-04-21 01:19:56.218915 (Thread-31): 01:19:56  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0ce220>]}
2022-04-21 01:19:56.248488 (Thread-31): 01:19:56  Sending event: {'category': 'dbt', 'action': 'resource_counts', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f169b20>]}
2022-04-21 01:19:56.248742 (Thread-31): 01:19:56  Found 3 models, 4 tests, 0 snapshots, 0 analyses, 179 macros, 0 operations, 0 seed files, 0 sources, 0 exposures, 0 metrics
2022-04-21 01:19:56.250996 (Thread-31): 01:19:56  The selection criterion '+models/_archive/orginal_query+' does not match any nodes
2022-04-21 01:19:56.251134 (Thread-31): 01:19:56  No nodes selected!
2022-04-21 01:19:56.252284 (Thread-31): sending response (<Response 1942 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:19:57.198001 (Thread-32): handling status request
2022-04-21 01:19:57.198368 (Thread-32): 01:19:57  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f1ece80>]}
2022-04-21 01:19:57.198829 (Thread-32): sending response (<Response 1546 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:19:57.204568 (Thread-33): handling list request
2022-04-21 01:19:57.204773 (Thread-33): 01:19:57  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0ae0a0>]}
2022-04-21 01:19:57.235916 (Thread-33): 01:19:57  Sending event: {'category': 'dbt', 'action': 'resource_counts', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0e2430>]}
2022-04-21 01:19:57.236193 (Thread-33): 01:19:57  Found 3 models, 4 tests, 0 snapshots, 0 analyses, 179 macros, 0 operations, 0 seed files, 0 sources, 0 exposures, 0 metrics
2022-04-21 01:19:57.236937 (Thread-33): 01:19:57  The selection criterion '+models/_archive/orginal_query.sql+' does not match any nodes
2022-04-21 01:19:57.237059 (Thread-33): 01:19:57  No nodes selected!
2022-04-21 01:19:57.238187 (Thread-33): sending response (<Response 1946 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:20:23.285730 (Thread-34): handling status request
2022-04-21 01:20:23.286082 (Thread-34): 01:20:23  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0ce790>]}
2022-04-21 01:20:23.286537 (Thread-34): sending response (<Response 1568 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:20:23.695899 (Thread-35): handling run_sql request
2022-04-21 01:20:23.696216 (Thread-35): 01:20:23  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0af280>]}
2022-04-21 01:20:25.952428 (Thread-35): sending response (<Response 138 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:20:25.976144 (MainThread): 01:20:25  Sending event: {'category': 'dbt', 'action': 'resource_counts', 'label': '28774b76-3860-43ef-afc8-b1af39d5c2da', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa83a6da6d0>]}
2022-04-21 01:20:25.976652 (MainThread): 01:20:25  Found 3 models, 4 tests, 0 snapshots, 0 analyses, 179 macros, 0 operations, 0 seed files, 0 sources, 0 exposures, 0 metrics
2022-04-21 01:20:25.977314 (Thread-1): 01:20:25  Acquiring new snowflake connection "rpc.my_new_project.request"
2022-04-21 01:20:25.977455 (Thread-1): 01:20:25  Began compiling node rpc.my_new_project.request
2022-04-21 01:20:25.977548 (Thread-1): 01:20:25  Compiling rpc.my_new_project.request
2022-04-21 01:20:25.978612 (Thread-1): 01:20:25  finished collecting timing info
2022-04-21 01:20:25.978743 (Thread-1): 01:20:25  Began executing node rpc.my_new_project.request
2022-04-21 01:20:25.981850 (Thread-1): 01:20:25  Using snowflake connection "rpc.my_new_project.request"
2022-04-21 01:20:25.981945 (Thread-1): 01:20:25  On rpc.my_new_project.request: -- import cte's
/*
First it is best to pull out your source tables into CTE's
Then we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)
cte's we found in query:
    `dbt-public.interview_task.orders` o
    `dbt-public.interview_task.devices` d
    `dbt-public.interview_task.orders` as fo -- potentially redunant
    `dbt-public.interview_task.addresses` oa 
    `dbt-public.interview_task.payments`
    
*/
-- logical cte's
-- final cte's
-- select statement

FROM (
    
    SELECT
      o.order_id,
      o.user_id,
      o.created_at,
      o.updated_at,
      o.shipped_at,
      o.currency,
      o.status AS order_status,
      CASE
        WHEN o.status IN (
          'paid',
          'completed',
          'shipped'
        ) THEN 'completed'
        ELSE o.status
      END AS order_status_category,
      CASE
        WHEN oa.country_code IS NULL THEN 'Null country'
        WHEN oa.country_code = 'US' THEN 'US'
        WHEN oa.country_code != 'US' THEN 'International'
      END AS country_type,
      o.shipping_method,
      CASE
        WHEN d.device = 'web' THEN 'desktop'
        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'
        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'
        when NULLIF(d.device, '') IS NULL THEN 'unknown'
        ELSE 'ERROR'
      END AS purchase_device_type,
      d.device AS purchase_device,
      CASE
        WHEN fo.first_order_id = o.order_id THEN 'new'
        ELSE 'repeat'
      END AS user_type,
      o.amount_total_cents,
      pa.gross_total_amount_cents,
      CASE
        WHEN o.currency = 'USD' then o.amount_total_cents
        ELSE pa.gross_total_amount_cents
      END AS total_amount_cents,
      pa.gross_tax_amount_cents,
      pa.gross_amount_cents,
      pa.gross_shipping_amount_cents
    FROM `dbt-public.interview_task.orders` o
    LEFT JOIN (
        SELECT
          DISTINCT cast(d.type_id as int64) as order_id,
          FIRST_VALUE(d.device) OVER (
            PARTITION BY d.type_id
            ORDER BY
              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING
              AND UNBOUNDED FOLLOWING
          ) AS device
        FROM `dbt-public.interview_task.devices` d
        WHERE d.type = 'order'
    ) d ON d.order_id = o.order_id
    LEFT JOIN (
        SELECT
          fo.user_id,
          MIN(fo.order_id) as first_order_id
        FROM `dbt-public.interview_task.orders` as fo
        WHERE
          fo.status != 'cancelled'
        GROUP BY
          fo.user_id
      ) fo ON o.user_id = fo.user_id
    left join `dbt-public.interview_task.addresses` oa 
      ON oa.order_id = o.order_id
    LEFT JOIN (
        select
          order_id,
          sum(
            CASE
              WHEN status = 'completed' THEN tax_amount_cents
              ELSE 0
            END
          ) as gross_tax_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN amount_cents
              ELSE 0
            END
          ) as gross_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN amount_shipping_cents
              ELSE 0
            END
        ) as gross_shipping_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents
              ELSE 0
            END
          ) as gross_total_amount_cents
        FROM `dbt-public.interview_task.payments`
        GROUP BY order_id
    ) pa ON pa.order_id = o.order_id
  )
limit 500
/* limit added automatically by dbt cloud */
2022-04-21 01:20:25.982026 (Thread-1): 01:20:25  Opening a new connection, currently in state init
2022-04-21 01:20:26.345201 (Thread-36): handling poll request
2022-04-21 01:20:26.345593 (Thread-36): 01:20:26  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0b4ac0>]}
2022-04-21 01:20:26.374501 (Thread-36): sending response (<Response 7618 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:20:27.159259 (Thread-1): 01:20:27  Snowflake adapter: Snowflake query id: 01a3beb0-0501-6083-0004-7d83048388ce
2022-04-21 01:20:27.159473 (Thread-1): 01:20:27  Snowflake adapter: Snowflake error: 001003 (42000): SQL compilation error:
syntax error line 1 at position 0 unexpected 'FROM'.
2022-04-21 01:20:27.159671 (Thread-1): 01:20:27  finished collecting timing info
2022-04-21 01:20:27.159858 (Thread-1): 01:20:27  On rpc.my_new_project.request: Close
2022-04-21 01:20:27.365486 (Thread-1): Got an exception: Database Error
  001003 (42000): SQL compilation error:
  syntax error line 1 at position 0 unexpected 'FROM'.
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 206, in exception_handler
    yield
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 74, in add_query
    cursor.execute(sql, bindings)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/cursor.py", line 789, in execute
    Error.errorhandler_wrapper(self.connection, self, error_class, errvalue)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 273, in errorhandler_wrapper
    handed_over = Error.hand_to_other_handler(
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 328, in hand_to_other_handler
    cursor.errorhandler(connection, cursor, error_class, error_value)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 207, in default_errorhandler
    raise error_class(
snowflake.connector.errors.ProgrammingError: 001003 (42000): SQL compilation error:
syntax error line 1 at position 0 unexpected 'FROM'.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 361, in safe_run
    result = self.compile_and_execute(manifest, ctx)
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 314, in compile_and_execute
    result = self.run(ctx.node, manifest)
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 403, in run
    return self.execute(compiled_node, manifest)
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/rpc/node_runners.py", line 90, in execute
    _, execute_result = self.adapter.execute(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/base/impl.py", line 225, in execute
    return self.connections.execute(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 127, in execute
    _, cursor = self.add_query(sql, auto_begin)
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 433, in add_query
    connection, cursor = super().add_query(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 83, in add_query
    return connection, cursor
  File "/usr/lib/python3.8/contextlib.py", line 131, in __exit__
    self.gen.throw(type, value, traceback)
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 223, in exception_handler
    raise DatabaseException(msg)
dbt.exceptions.DatabaseException: Database Error
  001003 (42000): SQL compilation error:
  syntax error line 1 at position 0 unexpected 'FROM'.
2022-04-21 01:20:27.366465 (Thread-1): Got exception RPCException(10003, Database Error, {'type': 'DatabaseException', 'message': "Database Error in rpc request (from remote system)\n  001003 (42000): SQL compilation error:\n  syntax error line 1 at position 0 unexpected 'FROM'.", 'raw_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as int64) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'compiled_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as int64) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'tags': None}, None)
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/task/sql_commands.py", line 147, in _in_thread
    self.node_results.append(runner.safe_run(self.manifest))
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 377, in safe_run
    result = self.error_result(ctx.node, error, started, [])
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/rpc/node_runners.py", line 56, in error_result
    raise error
dbt_rpc.rpc.error.RPCException: RPCException(10003, Database Error, {'type': 'DatabaseException', 'message': "Database Error in rpc request (from remote system)\n  001003 (42000): SQL compilation error:\n  syntax error line 1 at position 0 unexpected 'FROM'.", 'raw_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as int64) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'compiled_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as int64) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'tags': None}, None)
2022-04-21 01:20:27.825514 (Thread-37): handling poll request
2022-04-21 01:20:27.825901 (Thread-37): 01:20:27  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0b4f40>]}
2022-04-21 01:20:27.826649 (Thread-37): sending response (<Response 38127 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:21:29.236789 (Thread-38): handling status request
2022-04-21 01:21:29.239142 (Thread-38): 01:21:29  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d038340>]}
2022-04-21 01:21:29.239655 (Thread-38): sending response (<Response 1568 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:21:29.679815 (Thread-39): handling run_sql request
2022-04-21 01:21:29.680081 (Thread-39): 01:21:29  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d038ca0>]}
2022-04-21 01:21:31.889443 (Thread-39): sending response (<Response 138 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:21:31.916339 (MainThread): 01:21:31  Sending event: {'category': 'dbt', 'action': 'resource_counts', 'label': '612d75d3-a4e3-496f-bc73-563519a20940', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe46f79a6a0>]}
2022-04-21 01:21:31.916855 (MainThread): 01:21:31  Found 3 models, 4 tests, 0 snapshots, 0 analyses, 179 macros, 0 operations, 0 seed files, 0 sources, 0 exposures, 0 metrics
2022-04-21 01:21:31.917527 (Thread-1): 01:21:31  Acquiring new snowflake connection "rpc.my_new_project.request"
2022-04-21 01:21:31.917661 (Thread-1): 01:21:31  Began compiling node rpc.my_new_project.request
2022-04-21 01:21:31.917754 (Thread-1): 01:21:31  Compiling rpc.my_new_project.request
2022-04-21 01:21:31.918839 (Thread-1): 01:21:31  finished collecting timing info
2022-04-21 01:21:31.918996 (Thread-1): 01:21:31  Began executing node rpc.my_new_project.request
2022-04-21 01:21:31.922482 (Thread-1): 01:21:31  Using snowflake connection "rpc.my_new_project.request"
2022-04-21 01:21:31.922582 (Thread-1): 01:21:31  On rpc.my_new_project.request: -- import cte's
/*
First it is best to pull out your source tables into CTE's
Then we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)
cte's we found in query:
    `dbt-public.interview_task.orders` o
    `dbt-public.interview_task.devices` d
    `dbt-public.interview_task.orders` as fo -- potentially redunant
    `dbt-public.interview_task.addresses` oa 
    `dbt-public.interview_task.payments`
    
*/
-- logical cte's
-- final cte's
-- select statement

SELECT
  *,
  amount_total_cents / 100 as amount_total,
  gross_total_amount_cents/ 100 as gross_total_amount,
  total_amount_cents/ 100 as total_amount,
  gross_tax_amount_cents/ 100 as gross_tax_amount,
  gross_amount_cents/ 100 as gross_amount,
  gross_shipping_amount_cents/ 100 as gross_shipping_amount 

FROM (
    
    SELECT
      o.order_id,
      o.user_id,
      o.created_at,
      o.updated_at,
      o.shipped_at,
      o.currency,
      o.status AS order_status,
      CASE
        WHEN o.status IN (
          'paid',
          'completed',
          'shipped'
        ) THEN 'completed'
        ELSE o.status
      END AS order_status_category,
      CASE
        WHEN oa.country_code IS NULL THEN 'Null country'
        WHEN oa.country_code = 'US' THEN 'US'
        WHEN oa.country_code != 'US' THEN 'International'
      END AS country_type,
      o.shipping_method,
      CASE
        WHEN d.device = 'web' THEN 'desktop'
        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'
        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'
        when NULLIF(d.device, '') IS NULL THEN 'unknown'
        ELSE 'ERROR'
      END AS purchase_device_type,
      d.device AS purchase_device,
      CASE
        WHEN fo.first_order_id = o.order_id THEN 'new'
        ELSE 'repeat'
      END AS user_type,
      o.amount_total_cents,
      pa.gross_total_amount_cents,
      CASE
        WHEN o.currency = 'USD' then o.amount_total_cents
        ELSE pa.gross_total_amount_cents
      END AS total_amount_cents,
      pa.gross_tax_amount_cents,
      pa.gross_amount_cents,
      pa.gross_shipping_amount_cents
    FROM `dbt-public.interview_task.orders` o
    LEFT JOIN (
        SELECT
          DISTINCT cast(d.type_id as int64) as order_id,
          FIRST_VALUE(d.device) OVER (
            PARTITION BY d.type_id
            ORDER BY
              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING
              AND UNBOUNDED FOLLOWING
          ) AS device
        FROM `dbt-public.interview_task.devices` d
        WHERE d.type = 'order'
    ) d ON d.order_id = o.order_id
    LEFT JOIN (
        SELECT
          fo.user_id,
          MIN(fo.order_id) as first_order_id
        FROM `dbt-public.interview_task.orders` as fo
        WHERE
          fo.status != 'cancelled'
        GROUP BY
          fo.user_id
      ) fo ON o.user_id = fo.user_id
    left join `dbt-public.interview_task.addresses` oa 
      ON oa.order_id = o.order_id
    LEFT JOIN (
        select
          order_id,
          sum(
            CASE
              WHEN status = 'completed' THEN tax_amount_cents
              ELSE 0
            END
          ) as gross_tax_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN amount_cents
              ELSE 0
            END
          ) as gross_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN amount_shipping_cents
              ELSE 0
            END
        ) as gross_shipping_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents
              ELSE 0
            END
          ) as gross_total_amount_cents
        FROM `dbt-public.interview_task.payments`
        GROUP BY order_id
    ) pa ON pa.order_id = o.order_id
  )
limit 500
/* limit added automatically by dbt cloud */
2022-04-21 01:21:31.922664 (Thread-1): 01:21:31  Opening a new connection, currently in state init
2022-04-21 01:21:32.247354 (Thread-40): handling poll request
2022-04-21 01:21:32.248238 (Thread-40): 01:21:32  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0b4e50>]}
2022-04-21 01:21:32.249075 (Thread-40): sending response (<Response 7955 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:21:32.914651 (Thread-1): 01:21:32  Snowflake adapter: Snowflake query id: 01a3beb1-0501-602e-0004-7d8304837ef2
2022-04-21 01:21:32.914912 (Thread-1): 01:21:32  Snowflake adapter: Snowflake error: 002040 (42601): SQL compilation error:
Unsupported data type 'INT64'.
2022-04-21 01:21:32.915163 (Thread-1): 01:21:32  finished collecting timing info
2022-04-21 01:21:32.915368 (Thread-1): 01:21:32  On rpc.my_new_project.request: Close
2022-04-21 01:21:33.117179 (Thread-1): Got an exception: Database Error
  002040 (42601): SQL compilation error:
  Unsupported data type 'INT64'.
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 206, in exception_handler
    yield
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 74, in add_query
    cursor.execute(sql, bindings)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/cursor.py", line 789, in execute
    Error.errorhandler_wrapper(self.connection, self, error_class, errvalue)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 273, in errorhandler_wrapper
    handed_over = Error.hand_to_other_handler(
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 328, in hand_to_other_handler
    cursor.errorhandler(connection, cursor, error_class, error_value)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 207, in default_errorhandler
    raise error_class(
snowflake.connector.errors.ProgrammingError: 002040 (42601): SQL compilation error:
Unsupported data type 'INT64'.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 361, in safe_run
    result = self.compile_and_execute(manifest, ctx)
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 314, in compile_and_execute
    result = self.run(ctx.node, manifest)
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 403, in run
    return self.execute(compiled_node, manifest)
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/rpc/node_runners.py", line 90, in execute
    _, execute_result = self.adapter.execute(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/base/impl.py", line 225, in execute
    return self.connections.execute(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 127, in execute
    _, cursor = self.add_query(sql, auto_begin)
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 433, in add_query
    connection, cursor = super().add_query(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 83, in add_query
    return connection, cursor
  File "/usr/lib/python3.8/contextlib.py", line 131, in __exit__
    self.gen.throw(type, value, traceback)
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 223, in exception_handler
    raise DatabaseException(msg)
dbt.exceptions.DatabaseException: Database Error
  002040 (42601): SQL compilation error:
  Unsupported data type 'INT64'.
2022-04-21 01:21:33.118154 (Thread-1): Got exception RPCException(10003, Database Error, {'type': 'DatabaseException', 'message': "Database Error in rpc request (from remote system)\n  002040 (42601): SQL compilation error:\n  Unsupported data type 'INT64'.", 'raw_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as int64) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'compiled_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as int64) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'tags': None}, None)
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/task/sql_commands.py", line 147, in _in_thread
    self.node_results.append(runner.safe_run(self.manifest))
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 377, in safe_run
    result = self.error_result(ctx.node, error, started, [])
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/rpc/node_runners.py", line 56, in error_result
    raise error
dbt_rpc.rpc.error.RPCException: RPCException(10003, Database Error, {'type': 'DatabaseException', 'message': "Database Error in rpc request (from remote system)\n  002040 (42601): SQL compilation error:\n  Unsupported data type 'INT64'.", 'raw_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as int64) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'compiled_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as int64) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'tags': None}, None)
2022-04-21 01:21:33.656996 (Thread-41): handling poll request
2022-04-21 01:21:33.657327 (Thread-41): 01:21:33  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d03d160>]}
2022-04-21 01:21:33.658280 (Thread-41): sending response (<Response 40404 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:23:48.949200 (Thread-42): handling status request
2022-04-21 01:23:48.951794 (Thread-42): 01:23:48  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d03d6a0>]}
2022-04-21 01:23:48.952518 (Thread-42): sending response (<Response 1568 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:23:49.325790 (Thread-43): handling run_sql request
2022-04-21 01:23:49.326104 (Thread-43): 01:23:49  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d03d910>]}
2022-04-21 01:23:51.541857 (Thread-43): sending response (<Response 138 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:23:51.569112 (MainThread): 01:23:51  Sending event: {'category': 'dbt', 'action': 'resource_counts', 'label': '3f22efce-de2b-4fc3-863b-f6e94a50093d', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbfe67da6d0>]}
2022-04-21 01:23:51.569616 (MainThread): 01:23:51  Found 3 models, 4 tests, 0 snapshots, 0 analyses, 179 macros, 0 operations, 0 seed files, 0 sources, 0 exposures, 0 metrics
2022-04-21 01:23:51.570260 (Thread-1): 01:23:51  Acquiring new snowflake connection "rpc.my_new_project.request"
2022-04-21 01:23:51.570405 (Thread-1): 01:23:51  Began compiling node rpc.my_new_project.request
2022-04-21 01:23:51.570500 (Thread-1): 01:23:51  Compiling rpc.my_new_project.request
2022-04-21 01:23:51.571622 (Thread-1): 01:23:51  finished collecting timing info
2022-04-21 01:23:51.571746 (Thread-1): 01:23:51  Began executing node rpc.my_new_project.request
2022-04-21 01:23:51.575260 (Thread-1): 01:23:51  Using snowflake connection "rpc.my_new_project.request"
2022-04-21 01:23:51.575359 (Thread-1): 01:23:51  On rpc.my_new_project.request: -- import cte's
/*
First it is best to pull out your source tables into CTE's
Then we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)
cte's we found in query:
    `dbt-public.interview_task.orders` o
    `dbt-public.interview_task.devices` d
    `dbt-public.interview_task.orders` as fo -- potentially redunant
    `dbt-public.interview_task.addresses` oa 
    `dbt-public.interview_task.payments`
    
*/
-- logical cte's
-- final cte's
-- select statement

SELECT
  *,
  amount_total_cents / 100 as amount_total,
  gross_total_amount_cents/ 100 as gross_total_amount,
  total_amount_cents/ 100 as total_amount,
  gross_tax_amount_cents/ 100 as gross_tax_amount,
  gross_amount_cents/ 100 as gross_amount,
  gross_shipping_amount_cents/ 100 as gross_shipping_amount 

FROM (
    
    SELECT
      o.order_id,
      o.user_id,
      o.created_at,
      o.updated_at,
      o.shipped_at,
      o.currency,
      o.status AS order_status,
      CASE
        WHEN o.status IN (
          'paid',
          'completed',
          'shipped'
        ) THEN 'completed'
        ELSE o.status
      END AS order_status_category,
      CASE
        WHEN oa.country_code IS NULL THEN 'Null country'
        WHEN oa.country_code = 'US' THEN 'US'
        WHEN oa.country_code != 'US' THEN 'International'
      END AS country_type,
      o.shipping_method,
      CASE
        WHEN d.device = 'web' THEN 'desktop'
        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'
        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'
        when NULLIF(d.device, '') IS NULL THEN 'unknown'
        ELSE 'ERROR'
      END AS purchase_device_type,
      d.device AS purchase_device,
      CASE
        WHEN fo.first_order_id = o.order_id THEN 'new'
        ELSE 'repeat'
      END AS user_type,
      o.amount_total_cents,
      pa.gross_total_amount_cents,
      CASE
        WHEN o.currency = 'USD' then o.amount_total_cents
        ELSE pa.gross_total_amount_cents
      END AS total_amount_cents,
      pa.gross_tax_amount_cents,
      pa.gross_amount_cents,
      pa.gross_shipping_amount_cents
    FROM `dbt-public.interview_task.orders` o
    LEFT JOIN (
        SELECT
          DISTINCT cast(d.type_id as int64) as order_id,
          FIRST_VALUE(d.device) OVER (
            PARTITION BY d.type_id
            ORDER BY
              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING
              AND UNBOUNDED FOLLOWING
          ) AS device
        FROM `dbt-public.interview_task.devices` d
        WHERE d.type = 'order'
    ) d ON d.order_id = o.order_id
    LEFT JOIN (
        SELECT
          fo.user_id,
          MIN(fo.order_id) as first_order_id
        FROM `dbt-public.interview_task.orders` as fo
        WHERE
          fo.status != 'cancelled'
        GROUP BY
          fo.user_id
      ) fo ON o.user_id = fo.user_id
    left join `dbt-public.interview_task.addresses` oa 
      ON oa.order_id = o.order_id
    LEFT JOIN (
        select
          order_id,
          sum(
            CASE
              WHEN status = 'completed' THEN tax_amount_cents
              ELSE 0
            END
          ) as gross_tax_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN amount_cents
              ELSE 0
            END
          ) as gross_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN amount_shipping_cents
              ELSE 0
            END
        ) as gross_shipping_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents
              ELSE 0
            END
          ) as gross_total_amount_cents
        FROM `dbt-public.interview_task.payments`
        GROUP BY order_id
    ) pa ON pa.order_id = o.order_id
  )
limit 500
/* limit added automatically by dbt cloud */
2022-04-21 01:23:51.575441 (Thread-1): 01:23:51  Opening a new connection, currently in state init
2022-04-21 01:23:51.881976 (Thread-44): handling poll request
2022-04-21 01:23:51.882361 (Thread-44): 01:23:51  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d0408e0>]}
2022-04-21 01:23:51.883245 (Thread-44): sending response (<Response 7955 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:23:52.461251 (Thread-1): 01:23:52  Snowflake adapter: Snowflake query id: 01a3beb3-0501-5f4a-0004-7d830483a0c6
2022-04-21 01:23:52.461467 (Thread-1): 01:23:52  Snowflake adapter: Snowflake error: 002040 (42601): SQL compilation error:
Unsupported data type 'INT64'.
2022-04-21 01:23:52.461653 (Thread-1): 01:23:52  finished collecting timing info
2022-04-21 01:23:52.461848 (Thread-1): 01:23:52  On rpc.my_new_project.request: Close
2022-04-21 01:23:52.643510 (Thread-1): Got an exception: Database Error
  002040 (42601): SQL compilation error:
  Unsupported data type 'INT64'.
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 206, in exception_handler
    yield
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 74, in add_query
    cursor.execute(sql, bindings)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/cursor.py", line 789, in execute
    Error.errorhandler_wrapper(self.connection, self, error_class, errvalue)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 273, in errorhandler_wrapper
    handed_over = Error.hand_to_other_handler(
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 328, in hand_to_other_handler
    cursor.errorhandler(connection, cursor, error_class, error_value)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 207, in default_errorhandler
    raise error_class(
snowflake.connector.errors.ProgrammingError: 002040 (42601): SQL compilation error:
Unsupported data type 'INT64'.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 361, in safe_run
    result = self.compile_and_execute(manifest, ctx)
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 314, in compile_and_execute
    result = self.run(ctx.node, manifest)
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 403, in run
    return self.execute(compiled_node, manifest)
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/rpc/node_runners.py", line 90, in execute
    _, execute_result = self.adapter.execute(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/base/impl.py", line 225, in execute
    return self.connections.execute(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 127, in execute
    _, cursor = self.add_query(sql, auto_begin)
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 433, in add_query
    connection, cursor = super().add_query(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 83, in add_query
    return connection, cursor
  File "/usr/lib/python3.8/contextlib.py", line 131, in __exit__
    self.gen.throw(type, value, traceback)
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 223, in exception_handler
    raise DatabaseException(msg)
dbt.exceptions.DatabaseException: Database Error
  002040 (42601): SQL compilation error:
  Unsupported data type 'INT64'.
2022-04-21 01:23:52.644500 (Thread-1): Got exception RPCException(10003, Database Error, {'type': 'DatabaseException', 'message': "Database Error in rpc request (from remote system)\n  002040 (42601): SQL compilation error:\n  Unsupported data type 'INT64'.", 'raw_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as int64) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'compiled_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as int64) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'tags': None}, None)
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/task/sql_commands.py", line 147, in _in_thread
    self.node_results.append(runner.safe_run(self.manifest))
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 377, in safe_run
    result = self.error_result(ctx.node, error, started, [])
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/rpc/node_runners.py", line 56, in error_result
    raise error
dbt_rpc.rpc.error.RPCException: RPCException(10003, Database Error, {'type': 'DatabaseException', 'message': "Database Error in rpc request (from remote system)\n  002040 (42601): SQL compilation error:\n  Unsupported data type 'INT64'.", 'raw_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as int64) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'compiled_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as int64) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'tags': None}, None)
2022-04-21 01:23:53.285006 (Thread-45): handling poll request
2022-04-21 01:23:53.285357 (Thread-45): 01:23:53  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d040b80>]}
2022-04-21 01:23:53.286059 (Thread-45): sending response (<Response 40404 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:29:24.062461 (Thread-46): handling status request
2022-04-21 01:29:24.064146 (Thread-46): 01:29:24  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d046370>]}
2022-04-21 01:29:24.064661 (Thread-46): sending response (<Response 1568 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:29:24.402678 (Thread-47): handling run_sql request
2022-04-21 01:29:24.403075 (Thread-47): 01:29:24  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d046550>]}
2022-04-21 01:29:26.684706 (Thread-47): sending response (<Response 138 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:29:26.711539 (MainThread): 01:29:26  Sending event: {'category': 'dbt', 'action': 'resource_counts', 'label': '316e1927-d005-4eb4-9101-957bd2cedbfd', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbdb74246a0>]}
2022-04-21 01:29:26.712091 (MainThread): 01:29:26  Found 3 models, 4 tests, 0 snapshots, 0 analyses, 179 macros, 0 operations, 0 seed files, 0 sources, 0 exposures, 0 metrics
2022-04-21 01:29:26.712749 (Thread-1): 01:29:26  Acquiring new snowflake connection "rpc.my_new_project.request"
2022-04-21 01:29:26.712894 (Thread-1): 01:29:26  Began compiling node rpc.my_new_project.request
2022-04-21 01:29:26.712988 (Thread-1): 01:29:26  Compiling rpc.my_new_project.request
2022-04-21 01:29:26.714109 (Thread-1): 01:29:26  finished collecting timing info
2022-04-21 01:29:26.714244 (Thread-1): 01:29:26  Began executing node rpc.my_new_project.request
2022-04-21 01:29:26.717787 (Thread-1): 01:29:26  Using snowflake connection "rpc.my_new_project.request"
2022-04-21 01:29:26.717889 (Thread-1): 01:29:26  On rpc.my_new_project.request: -- import cte's
/*
First it is best to pull out your source tables into CTE's
Then we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)
cte's we found in query:
    `dbt-public.interview_task.orders` o
    `dbt-public.interview_task.devices` d
    `dbt-public.interview_task.orders` as fo -- potentially redunant
    `dbt-public.interview_task.addresses` oa 
    `dbt-public.interview_task.payments`
    
*/
-- logical cte's
-- final cte's
-- select statement

SELECT
  *,
  amount_total_cents / 100 as amount_total,
  gross_total_amount_cents/ 100 as gross_total_amount,
  total_amount_cents/ 100 as total_amount,
  gross_tax_amount_cents/ 100 as gross_tax_amount,
  gross_amount_cents/ 100 as gross_amount,
  gross_shipping_amount_cents/ 100 as gross_shipping_amount 

FROM (
    
    SELECT
      o.order_id,
      o.user_id,
      o.created_at,
      o.updated_at,
      o.shipped_at,
      o.currency,
      o.status AS order_status,
      CASE
        WHEN o.status IN (
          'paid',
          'completed',
          'shipped'
        ) THEN 'completed'
        ELSE o.status
      END AS order_status_category,
      CASE
        WHEN oa.country_code IS NULL THEN 'Null country'
        WHEN oa.country_code = 'US' THEN 'US'
        WHEN oa.country_code != 'US' THEN 'International'
      END AS country_type,
      o.shipping_method,
      CASE
        WHEN d.device = 'web' THEN 'desktop'
        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'
        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'
        when NULLIF(d.device, '') IS NULL THEN 'unknown'
        ELSE 'ERROR'
      END AS purchase_device_type,
      d.device AS purchase_device,
      CASE
        WHEN fo.first_order_id = o.order_id THEN 'new'
        ELSE 'repeat'
      END AS user_type,
      o.amount_total_cents,
      pa.gross_total_amount_cents,
      CASE
        WHEN o.currency = 'USD' then o.amount_total_cents
        ELSE pa.gross_total_amount_cents
      END AS total_amount_cents,
      pa.gross_tax_amount_cents,
      pa.gross_amount_cents,
      pa.gross_shipping_amount_cents
    FROM `dbt-public.interview_task.orders` o
    LEFT JOIN (
        SELECT
          DISTINCT cast(d.type_id as float) as order_id,
          FIRST_VALUE(d.device) OVER (
            PARTITION BY d.type_id
            ORDER BY
              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING
              AND UNBOUNDED FOLLOWING
          ) AS device
        FROM `dbt-public.interview_task.devices` d
        WHERE d.type = 'order'
    ) d ON d.order_id = o.order_id
    LEFT JOIN (
        SELECT
          fo.user_id,
          MIN(fo.order_id) as first_order_id
        FROM `dbt-public.interview_task.orders` as fo
        WHERE
          fo.status != 'cancelled'
        GROUP BY
          fo.user_id
      ) fo ON o.user_id = fo.user_id
    left join `dbt-public.interview_task.addresses` oa 
      ON oa.order_id = o.order_id
    LEFT JOIN (
        select
          order_id,
          sum(
            CASE
              WHEN status = 'completed' THEN tax_amount_cents
              ELSE 0
            END
          ) as gross_tax_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN amount_cents
              ELSE 0
            END
          ) as gross_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN amount_shipping_cents
              ELSE 0
            END
        ) as gross_shipping_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents
              ELSE 0
            END
          ) as gross_total_amount_cents
        FROM `dbt-public.interview_task.payments`
        GROUP BY order_id
    ) pa ON pa.order_id = o.order_id
  )
limit 500
/* limit added automatically by dbt cloud */
2022-04-21 01:29:26.717972 (Thread-1): 01:29:26  Opening a new connection, currently in state init
2022-04-21 01:29:27.037820 (Thread-48): handling poll request
2022-04-21 01:29:27.038216 (Thread-48): 01:29:27  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d04e520>]}
2022-04-21 01:29:27.039089 (Thread-48): sending response (<Response 7955 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:29:27.654005 (Thread-1): 01:29:27  Snowflake adapter: Snowflake query id: 01a3beb9-0501-602e-0004-7d8304837f7e
2022-04-21 01:29:27.654239 (Thread-1): 01:29:27  Snowflake adapter: Snowflake error: 002003 (42S02): SQL compilation error:
Object '"`DBT-PUBLIC.INTERVIEW_TASK.ORDERS`"' does not exist or not authorized.
2022-04-21 01:29:27.654430 (Thread-1): 01:29:27  finished collecting timing info
2022-04-21 01:29:27.654624 (Thread-1): 01:29:27  On rpc.my_new_project.request: Close
2022-04-21 01:29:27.850118 (Thread-1): Got an exception: Database Error
  002003 (42S02): SQL compilation error:
  Object '"`DBT-PUBLIC.INTERVIEW_TASK.ORDERS`"' does not exist or not authorized.
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 206, in exception_handler
    yield
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 74, in add_query
    cursor.execute(sql, bindings)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/cursor.py", line 789, in execute
    Error.errorhandler_wrapper(self.connection, self, error_class, errvalue)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 273, in errorhandler_wrapper
    handed_over = Error.hand_to_other_handler(
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 328, in hand_to_other_handler
    cursor.errorhandler(connection, cursor, error_class, error_value)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 207, in default_errorhandler
    raise error_class(
snowflake.connector.errors.ProgrammingError: 002003 (42S02): SQL compilation error:
Object '"`DBT-PUBLIC.INTERVIEW_TASK.ORDERS`"' does not exist or not authorized.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 361, in safe_run
    result = self.compile_and_execute(manifest, ctx)
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 314, in compile_and_execute
    result = self.run(ctx.node, manifest)
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 403, in run
    return self.execute(compiled_node, manifest)
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/rpc/node_runners.py", line 90, in execute
    _, execute_result = self.adapter.execute(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/base/impl.py", line 225, in execute
    return self.connections.execute(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 127, in execute
    _, cursor = self.add_query(sql, auto_begin)
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 433, in add_query
    connection, cursor = super().add_query(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 83, in add_query
    return connection, cursor
  File "/usr/lib/python3.8/contextlib.py", line 131, in __exit__
    self.gen.throw(type, value, traceback)
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 223, in exception_handler
    raise DatabaseException(msg)
dbt.exceptions.DatabaseException: Database Error
  002003 (42S02): SQL compilation error:
  Object '"`DBT-PUBLIC.INTERVIEW_TASK.ORDERS`"' does not exist or not authorized.
2022-04-21 01:29:27.851285 (Thread-1): Got exception RPCException(10003, Database Error, {'type': 'DatabaseException', 'message': 'Database Error in rpc request (from remote system)\n  002003 (42S02): SQL compilation error:\n  Object \'"`DBT-PUBLIC.INTERVIEW_TASK.ORDERS`"\' does not exist or not authorized.', 'raw_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as float) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'compiled_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as float) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'tags': None}, None)
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/task/sql_commands.py", line 147, in _in_thread
    self.node_results.append(runner.safe_run(self.manifest))
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 377, in safe_run
    result = self.error_result(ctx.node, error, started, [])
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/rpc/node_runners.py", line 56, in error_result
    raise error
dbt_rpc.rpc.error.RPCException: RPCException(10003, Database Error, {'type': 'DatabaseException', 'message': 'Database Error in rpc request (from remote system)\n  002003 (42S02): SQL compilation error:\n  Object \'"`DBT-PUBLIC.INTERVIEW_TASK.ORDERS`"\' does not exist or not authorized.', 'raw_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as float) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'compiled_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\ncte's we found in query:\r\n    `dbt-public.interview_task.orders` o\r\n    `dbt-public.interview_task.devices` d\r\n    `dbt-public.interview_task.orders` as fo -- potentially redunant\r\n    `dbt-public.interview_task.addresses` oa \r\n    `dbt-public.interview_task.payments`\r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `dbt-public.interview_task.orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as float) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `dbt-public.interview_task.devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `dbt-public.interview_task.orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `dbt-public.interview_task.addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `dbt-public.interview_task.payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'tags': None}, None)
2022-04-21 01:29:28.378806 (Thread-49): handling poll request
2022-04-21 01:29:28.379184 (Thread-49): 01:29:28  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d04e820>]}
2022-04-21 01:29:28.380303 (Thread-49): sending response (<Response 40765 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:33:02.696225 (Thread-50): handling status request
2022-04-21 01:33:02.697981 (Thread-50): 01:33:02  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d040340>]}
2022-04-21 01:33:02.698468 (Thread-50): sending response (<Response 1568 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:33:03.085444 (Thread-51): handling run_sql request
2022-04-21 01:33:03.085804 (Thread-51): 01:33:03  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d04e790>]}
2022-04-21 01:33:05.301495 (Thread-51): sending response (<Response 138 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:33:05.328026 (MainThread): 01:33:05  Sending event: {'category': 'dbt', 'action': 'resource_counts', 'label': '64b36024-7f6f-4a77-8158-fdc38395e148', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fee541f9400>]}
2022-04-21 01:33:05.328540 (MainThread): 01:33:05  Found 3 models, 4 tests, 0 snapshots, 0 analyses, 179 macros, 0 operations, 0 seed files, 0 sources, 0 exposures, 0 metrics
2022-04-21 01:33:05.329197 (Thread-1): 01:33:05  Acquiring new snowflake connection "rpc.my_new_project.request"
2022-04-21 01:33:05.329347 (Thread-1): 01:33:05  Began compiling node rpc.my_new_project.request
2022-04-21 01:33:05.329443 (Thread-1): 01:33:05  Compiling rpc.my_new_project.request
2022-04-21 01:33:05.330523 (Thread-1): 01:33:05  finished collecting timing info
2022-04-21 01:33:05.330652 (Thread-1): 01:33:05  Began executing node rpc.my_new_project.request
2022-04-21 01:33:05.334241 (Thread-1): 01:33:05  Using snowflake connection "rpc.my_new_project.request"
2022-04-21 01:33:05.334342 (Thread-1): 01:33:05  On rpc.my_new_project.request: -- import cte's
/*
First it is best to pull out your source tables into CTE's
Then we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)

cte's we found in query:
    `raw.interview_sample_data.intreview_orders` o
    `raw.interview_sample_data.intreview_devices` d
    `raw.interview_sample_data.intreview_orders` as fo -- potentially redunant
    `raw.interview_sample_data.intreview_addresses` oa 
    `raw.interview_sample_data.intreview_payments`

a couple of errors that were resolved:
  data type int64 to float
  rename tables to: 
    
*/
-- logical cte's
-- final cte's
-- select statement

SELECT
  *,
  amount_total_cents / 100 as amount_total,
  gross_total_amount_cents/ 100 as gross_total_amount,
  total_amount_cents/ 100 as total_amount,
  gross_tax_amount_cents/ 100 as gross_tax_amount,
  gross_amount_cents/ 100 as gross_amount,
  gross_shipping_amount_cents/ 100 as gross_shipping_amount 

FROM (
    
    SELECT
      o.order_id,
      o.user_id,
      o.created_at,
      o.updated_at,
      o.shipped_at,
      o.currency,
      o.status AS order_status,
      CASE
        WHEN o.status IN (
          'paid',
          'completed',
          'shipped'
        ) THEN 'completed'
        ELSE o.status
      END AS order_status_category,
      CASE
        WHEN oa.country_code IS NULL THEN 'Null country'
        WHEN oa.country_code = 'US' THEN 'US'
        WHEN oa.country_code != 'US' THEN 'International'
      END AS country_type,
      o.shipping_method,
      CASE
        WHEN d.device = 'web' THEN 'desktop'
        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'
        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'
        when NULLIF(d.device, '') IS NULL THEN 'unknown'
        ELSE 'ERROR'
      END AS purchase_device_type,
      d.device AS purchase_device,
      CASE
        WHEN fo.first_order_id = o.order_id THEN 'new'
        ELSE 'repeat'
      END AS user_type,
      o.amount_total_cents,
      pa.gross_total_amount_cents,
      CASE
        WHEN o.currency = 'USD' then o.amount_total_cents
        ELSE pa.gross_total_amount_cents
      END AS total_amount_cents,
      pa.gross_tax_amount_cents,
      pa.gross_amount_cents,
      pa.gross_shipping_amount_cents
    FROM `raw.interview_sample_data.intreview_orders` o
    LEFT JOIN (
        SELECT
          DISTINCT cast(d.type_id as float) as order_id,
          FIRST_VALUE(d.device) OVER (
            PARTITION BY d.type_id
            ORDER BY
              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING
              AND UNBOUNDED FOLLOWING
          ) AS device
        FROM `raw.interview_sample_data.intreview_devices` d
        WHERE d.type = 'order'
    ) d ON d.order_id = o.order_id
    LEFT JOIN (
        SELECT
          fo.user_id,
          MIN(fo.order_id) as first_order_id
        FROM `raw.interview_sample_data.intreview_orders` as fo
        WHERE
          fo.status != 'cancelled'
        GROUP BY
          fo.user_id
      ) fo ON o.user_id = fo.user_id
    left join `raw.interview_sample_data.intreview_addresses` oa 
      ON oa.order_id = o.order_id
    LEFT JOIN (
        select
          order_id,
          sum(
            CASE
              WHEN status = 'completed' THEN tax_amount_cents
              ELSE 0
            END
          ) as gross_tax_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN amount_cents
              ELSE 0
            END
          ) as gross_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN amount_shipping_cents
              ELSE 0
            END
        ) as gross_shipping_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents
              ELSE 0
            END
          ) as gross_total_amount_cents
        FROM `raw.interview_sample_data.intreview_payments`
        GROUP BY order_id
    ) pa ON pa.order_id = o.order_id
  )
limit 500
/* limit added automatically by dbt cloud */
2022-04-21 01:33:05.334425 (Thread-1): 01:33:05  Opening a new connection, currently in state init
2022-04-21 01:33:05.658078 (Thread-52): handling poll request
2022-04-21 01:33:05.658444 (Thread-52): 01:33:05  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d058790>]}
2022-04-21 01:33:05.659315 (Thread-52): sending response (<Response 8159 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:33:06.392746 (Thread-1): 01:33:06  Snowflake adapter: Snowflake query id: 01a3bebd-0501-5fd8-0004-7d83048399e2
2022-04-21 01:33:06.392986 (Thread-1): 01:33:06  Snowflake adapter: Snowflake error: 002003 (42S02): SQL compilation error:
Object '"`RAW.INTERVIEW_SAMPLE_DATA.INTREVIEW_ORDERS`"' does not exist or not authorized.
2022-04-21 01:33:06.393170 (Thread-1): 01:33:06  finished collecting timing info
2022-04-21 01:33:06.393364 (Thread-1): 01:33:06  On rpc.my_new_project.request: Close
2022-04-21 01:33:06.631592 (Thread-1): Got an exception: Database Error
  002003 (42S02): SQL compilation error:
  Object '"`RAW.INTERVIEW_SAMPLE_DATA.INTREVIEW_ORDERS`"' does not exist or not authorized.
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 206, in exception_handler
    yield
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 74, in add_query
    cursor.execute(sql, bindings)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/cursor.py", line 789, in execute
    Error.errorhandler_wrapper(self.connection, self, error_class, errvalue)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 273, in errorhandler_wrapper
    handed_over = Error.hand_to_other_handler(
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 328, in hand_to_other_handler
    cursor.errorhandler(connection, cursor, error_class, error_value)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 207, in default_errorhandler
    raise error_class(
snowflake.connector.errors.ProgrammingError: 002003 (42S02): SQL compilation error:
Object '"`RAW.INTERVIEW_SAMPLE_DATA.INTREVIEW_ORDERS`"' does not exist or not authorized.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 361, in safe_run
    result = self.compile_and_execute(manifest, ctx)
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 314, in compile_and_execute
    result = self.run(ctx.node, manifest)
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 403, in run
    return self.execute(compiled_node, manifest)
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/rpc/node_runners.py", line 90, in execute
    _, execute_result = self.adapter.execute(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/base/impl.py", line 225, in execute
    return self.connections.execute(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 127, in execute
    _, cursor = self.add_query(sql, auto_begin)
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 433, in add_query
    connection, cursor = super().add_query(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 83, in add_query
    return connection, cursor
  File "/usr/lib/python3.8/contextlib.py", line 131, in __exit__
    self.gen.throw(type, value, traceback)
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 223, in exception_handler
    raise DatabaseException(msg)
dbt.exceptions.DatabaseException: Database Error
  002003 (42S02): SQL compilation error:
  Object '"`RAW.INTERVIEW_SAMPLE_DATA.INTREVIEW_ORDERS`"' does not exist or not authorized.
2022-04-21 01:33:06.632552 (Thread-1): Got exception RPCException(10003, Database Error, {'type': 'DatabaseException', 'message': 'Database Error in rpc request (from remote system)\n  002003 (42S02): SQL compilation error:\n  Object \'"`RAW.INTERVIEW_SAMPLE_DATA.INTREVIEW_ORDERS`"\' does not exist or not authorized.', 'raw_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\n\r\ncte's we found in query:\r\n    `raw.interview_sample_data.intreview_orders` o\r\n    `raw.interview_sample_data.intreview_devices` d\r\n    `raw.interview_sample_data.intreview_orders` as fo -- potentially redunant\r\n    `raw.interview_sample_data.intreview_addresses` oa \r\n    `raw.interview_sample_data.intreview_payments`\r\n\r\na couple of errors that were resolved:\r\n  data type int64 to float\r\n  rename tables to: \r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `raw.interview_sample_data.intreview_orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as float) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `raw.interview_sample_data.intreview_devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `raw.interview_sample_data.intreview_orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `raw.interview_sample_data.intreview_addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `raw.interview_sample_data.intreview_payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'compiled_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\n\r\ncte's we found in query:\r\n    `raw.interview_sample_data.intreview_orders` o\r\n    `raw.interview_sample_data.intreview_devices` d\r\n    `raw.interview_sample_data.intreview_orders` as fo -- potentially redunant\r\n    `raw.interview_sample_data.intreview_addresses` oa \r\n    `raw.interview_sample_data.intreview_payments`\r\n\r\na couple of errors that were resolved:\r\n  data type int64 to float\r\n  rename tables to: \r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `raw.interview_sample_data.intreview_orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as float) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `raw.interview_sample_data.intreview_devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `raw.interview_sample_data.intreview_orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `raw.interview_sample_data.intreview_addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `raw.interview_sample_data.intreview_payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'tags': None}, None)
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/task/sql_commands.py", line 147, in _in_thread
    self.node_results.append(runner.safe_run(self.manifest))
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 377, in safe_run
    result = self.error_result(ctx.node, error, started, [])
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/rpc/node_runners.py", line 56, in error_result
    raise error
dbt_rpc.rpc.error.RPCException: RPCException(10003, Database Error, {'type': 'DatabaseException', 'message': 'Database Error in rpc request (from remote system)\n  002003 (42S02): SQL compilation error:\n  Object \'"`RAW.INTERVIEW_SAMPLE_DATA.INTREVIEW_ORDERS`"\' does not exist or not authorized.', 'raw_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\n\r\ncte's we found in query:\r\n    `raw.interview_sample_data.intreview_orders` o\r\n    `raw.interview_sample_data.intreview_devices` d\r\n    `raw.interview_sample_data.intreview_orders` as fo -- potentially redunant\r\n    `raw.interview_sample_data.intreview_addresses` oa \r\n    `raw.interview_sample_data.intreview_payments`\r\n\r\na couple of errors that were resolved:\r\n  data type int64 to float\r\n  rename tables to: \r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `raw.interview_sample_data.intreview_orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as float) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `raw.interview_sample_data.intreview_devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `raw.interview_sample_data.intreview_orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `raw.interview_sample_data.intreview_addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `raw.interview_sample_data.intreview_payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'compiled_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\n\r\ncte's we found in query:\r\n    `raw.interview_sample_data.intreview_orders` o\r\n    `raw.interview_sample_data.intreview_devices` d\r\n    `raw.interview_sample_data.intreview_orders` as fo -- potentially redunant\r\n    `raw.interview_sample_data.intreview_addresses` oa \r\n    `raw.interview_sample_data.intreview_payments`\r\n\r\na couple of errors that were resolved:\r\n  data type int64 to float\r\n  rename tables to: \r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM `raw.interview_sample_data.intreview_orders` o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as float) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM `raw.interview_sample_data.intreview_devices` d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM `raw.interview_sample_data.intreview_orders` as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join `raw.interview_sample_data.intreview_addresses` oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM `raw.interview_sample_data.intreview_payments`\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'tags': None}, None)
2022-04-21 01:33:07.041684 (Thread-53): handling poll request
2022-04-21 01:33:07.041998 (Thread-53): 01:33:07  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d058a90>]}
2022-04-21 01:33:07.042714 (Thread-53): sending response (<Response 42303 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:33:22.583895 (Thread-54): handling status request
2022-04-21 01:33:22.584223 (Thread-54): 01:33:22  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d058f10>]}
2022-04-21 01:33:22.584722 (Thread-54): sending response (<Response 1568 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:33:22.952498 (Thread-55): handling run_sql request
2022-04-21 01:33:22.952798 (Thread-55): 01:33:22  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d0660d0>]}
2022-04-21 01:33:25.167370 (Thread-55): sending response (<Response 138 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:33:25.191246 (MainThread): 01:33:25  Sending event: {'category': 'dbt', 'action': 'resource_counts', 'label': 'be1fa11d-c25a-4528-aaf9-4188df147145', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb6c73a7e20>]}
2022-04-21 01:33:25.191751 (MainThread): 01:33:25  Found 3 models, 4 tests, 0 snapshots, 0 analyses, 179 macros, 0 operations, 0 seed files, 0 sources, 0 exposures, 0 metrics
2022-04-21 01:33:25.192402 (Thread-1): 01:33:25  Acquiring new snowflake connection "rpc.my_new_project.request"
2022-04-21 01:33:25.192557 (Thread-1): 01:33:25  Began compiling node rpc.my_new_project.request
2022-04-21 01:33:25.192651 (Thread-1): 01:33:25  Compiling rpc.my_new_project.request
2022-04-21 01:33:25.193755 (Thread-1): 01:33:25  finished collecting timing info
2022-04-21 01:33:25.193880 (Thread-1): 01:33:25  Began executing node rpc.my_new_project.request
2022-04-21 01:33:25.197489 (Thread-1): 01:33:25  Using snowflake connection "rpc.my_new_project.request"
2022-04-21 01:33:25.197589 (Thread-1): 01:33:25  On rpc.my_new_project.request: -- import cte's
/*
First it is best to pull out your source tables into CTE's
Then we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)

cte's we found in query:
    raw.interview_sample_data.intreview_orders o
    raw.interview_sample_data.intreview_devices d
    raw.interview_sample_data.intreview_orders as fo -- potentially redunant
    raw.interview_sample_data.intreview_addresses oa 
    raw.interview_sample_data.intreview_payments

a couple of errors that were resolved:
  data type int64 to float
  rename tables to: 
    
*/
-- logical cte's
-- final cte's
-- select statement

SELECT
  *,
  amount_total_cents / 100 as amount_total,
  gross_total_amount_cents/ 100 as gross_total_amount,
  total_amount_cents/ 100 as total_amount,
  gross_tax_amount_cents/ 100 as gross_tax_amount,
  gross_amount_cents/ 100 as gross_amount,
  gross_shipping_amount_cents/ 100 as gross_shipping_amount 

FROM (
    
    SELECT
      o.order_id,
      o.user_id,
      o.created_at,
      o.updated_at,
      o.shipped_at,
      o.currency,
      o.status AS order_status,
      CASE
        WHEN o.status IN (
          'paid',
          'completed',
          'shipped'
        ) THEN 'completed'
        ELSE o.status
      END AS order_status_category,
      CASE
        WHEN oa.country_code IS NULL THEN 'Null country'
        WHEN oa.country_code = 'US' THEN 'US'
        WHEN oa.country_code != 'US' THEN 'International'
      END AS country_type,
      o.shipping_method,
      CASE
        WHEN d.device = 'web' THEN 'desktop'
        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'
        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'
        when NULLIF(d.device, '') IS NULL THEN 'unknown'
        ELSE 'ERROR'
      END AS purchase_device_type,
      d.device AS purchase_device,
      CASE
        WHEN fo.first_order_id = o.order_id THEN 'new'
        ELSE 'repeat'
      END AS user_type,
      o.amount_total_cents,
      pa.gross_total_amount_cents,
      CASE
        WHEN o.currency = 'USD' then o.amount_total_cents
        ELSE pa.gross_total_amount_cents
      END AS total_amount_cents,
      pa.gross_tax_amount_cents,
      pa.gross_amount_cents,
      pa.gross_shipping_amount_cents
    FROM raw.interview_sample_data.intreview_orders o
    LEFT JOIN (
        SELECT
          DISTINCT cast(d.type_id as float) as order_id,
          FIRST_VALUE(d.device) OVER (
            PARTITION BY d.type_id
            ORDER BY
              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING
              AND UNBOUNDED FOLLOWING
          ) AS device
        FROM raw.interview_sample_data.intreview_devices d
        WHERE d.type = 'order'
    ) d ON d.order_id = o.order_id
    LEFT JOIN (
        SELECT
          fo.user_id,
          MIN(fo.order_id) as first_order_id
        FROM raw.interview_sample_data.intreview_orders as fo
        WHERE
          fo.status != 'cancelled'
        GROUP BY
          fo.user_id
      ) fo ON o.user_id = fo.user_id
    left join raw.interview_sample_data.intreview_addresses oa 
      ON oa.order_id = o.order_id
    LEFT JOIN (
        select
          order_id,
          sum(
            CASE
              WHEN status = 'completed' THEN tax_amount_cents
              ELSE 0
            END
          ) as gross_tax_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN amount_cents
              ELSE 0
            END
          ) as gross_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN amount_shipping_cents
              ELSE 0
            END
        ) as gross_shipping_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents
              ELSE 0
            END
          ) as gross_total_amount_cents
        FROM raw.interview_sample_data.intreview_payments
        GROUP BY order_id
    ) pa ON pa.order_id = o.order_id
  )
limit 500
/* limit added automatically by dbt cloud */
2022-04-21 01:33:25.197671 (Thread-1): 01:33:25  Opening a new connection, currently in state init
2022-04-21 01:33:25.519146 (Thread-56): handling poll request
2022-04-21 01:33:25.519560 (Thread-56): 01:33:25  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d06c100>]}
2022-04-21 01:33:25.520394 (Thread-56): sending response (<Response 8139 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:33:26.103914 (Thread-1): 01:33:26  Snowflake adapter: Snowflake query id: 01a3bebd-0501-6083-0004-7d8304838a72
2022-04-21 01:33:26.104160 (Thread-1): 01:33:26  Snowflake adapter: Snowflake error: 002003 (42S02): SQL compilation error:
Object 'RAW.INTERVIEW_SAMPLE_DATA.INTREVIEW_ORDERS' does not exist or not authorized.
2022-04-21 01:33:26.104385 (Thread-1): 01:33:26  finished collecting timing info
2022-04-21 01:33:26.104613 (Thread-1): 01:33:26  On rpc.my_new_project.request: Close
2022-04-21 01:33:26.315277 (Thread-1): Got an exception: Database Error
  002003 (42S02): SQL compilation error:
  Object 'RAW.INTERVIEW_SAMPLE_DATA.INTREVIEW_ORDERS' does not exist or not authorized.
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 206, in exception_handler
    yield
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 74, in add_query
    cursor.execute(sql, bindings)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/cursor.py", line 789, in execute
    Error.errorhandler_wrapper(self.connection, self, error_class, errvalue)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 273, in errorhandler_wrapper
    handed_over = Error.hand_to_other_handler(
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 328, in hand_to_other_handler
    cursor.errorhandler(connection, cursor, error_class, error_value)
  File "/usr/local/lib/python3.8/dist-packages/snowflake/connector/errors.py", line 207, in default_errorhandler
    raise error_class(
snowflake.connector.errors.ProgrammingError: 002003 (42S02): SQL compilation error:
Object 'RAW.INTERVIEW_SAMPLE_DATA.INTREVIEW_ORDERS' does not exist or not authorized.

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 361, in safe_run
    result = self.compile_and_execute(manifest, ctx)
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 314, in compile_and_execute
    result = self.run(ctx.node, manifest)
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 403, in run
    return self.execute(compiled_node, manifest)
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/rpc/node_runners.py", line 90, in execute
    _, execute_result = self.adapter.execute(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/base/impl.py", line 225, in execute
    return self.connections.execute(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 127, in execute
    _, cursor = self.add_query(sql, auto_begin)
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 433, in add_query
    connection, cursor = super().add_query(
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/sql/connections.py", line 83, in add_query
    return connection, cursor
  File "/usr/lib/python3.8/contextlib.py", line 131, in __exit__
    self.gen.throw(type, value, traceback)
  File "/usr/local/lib/python3.8/dist-packages/dbt/adapters/snowflake/connections.py", line 223, in exception_handler
    raise DatabaseException(msg)
dbt.exceptions.DatabaseException: Database Error
  002003 (42S02): SQL compilation error:
  Object 'RAW.INTERVIEW_SAMPLE_DATA.INTREVIEW_ORDERS' does not exist or not authorized.
2022-04-21 01:33:26.316262 (Thread-1): Got exception RPCException(10003, Database Error, {'type': 'DatabaseException', 'message': "Database Error in rpc request (from remote system)\n  002003 (42S02): SQL compilation error:\n  Object 'RAW.INTERVIEW_SAMPLE_DATA.INTREVIEW_ORDERS' does not exist or not authorized.", 'raw_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\n\r\ncte's we found in query:\r\n    raw.interview_sample_data.intreview_orders o\r\n    raw.interview_sample_data.intreview_devices d\r\n    raw.interview_sample_data.intreview_orders as fo -- potentially redunant\r\n    raw.interview_sample_data.intreview_addresses oa \r\n    raw.interview_sample_data.intreview_payments\r\n\r\na couple of errors that were resolved:\r\n  data type int64 to float\r\n  rename tables to: \r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM raw.interview_sample_data.intreview_orders o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as float) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM raw.interview_sample_data.intreview_devices d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM raw.interview_sample_data.intreview_orders as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join raw.interview_sample_data.intreview_addresses oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM raw.interview_sample_data.intreview_payments\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'compiled_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\n\r\ncte's we found in query:\r\n    raw.interview_sample_data.intreview_orders o\r\n    raw.interview_sample_data.intreview_devices d\r\n    raw.interview_sample_data.intreview_orders as fo -- potentially redunant\r\n    raw.interview_sample_data.intreview_addresses oa \r\n    raw.interview_sample_data.intreview_payments\r\n\r\na couple of errors that were resolved:\r\n  data type int64 to float\r\n  rename tables to: \r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM raw.interview_sample_data.intreview_orders o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as float) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM raw.interview_sample_data.intreview_devices d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM raw.interview_sample_data.intreview_orders as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join raw.interview_sample_data.intreview_addresses oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM raw.interview_sample_data.intreview_payments\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'tags': None}, None)
Traceback (most recent call last):
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/task/sql_commands.py", line 147, in _in_thread
    self.node_results.append(runner.safe_run(self.manifest))
  File "/usr/local/lib/python3.8/dist-packages/dbt/task/base.py", line 377, in safe_run
    result = self.error_result(ctx.node, error, started, [])
  File "/usr/local/lib/python3.8/dist-packages/dbt_rpc/rpc/node_runners.py", line 56, in error_result
    raise error
dbt_rpc.rpc.error.RPCException: RPCException(10003, Database Error, {'type': 'DatabaseException', 'message': "Database Error in rpc request (from remote system)\n  002003 (42S02): SQL compilation error:\n  Object 'RAW.INTERVIEW_SAMPLE_DATA.INTREVIEW_ORDERS' does not exist or not authorized.", 'raw_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\n\r\ncte's we found in query:\r\n    raw.interview_sample_data.intreview_orders o\r\n    raw.interview_sample_data.intreview_devices d\r\n    raw.interview_sample_data.intreview_orders as fo -- potentially redunant\r\n    raw.interview_sample_data.intreview_addresses oa \r\n    raw.interview_sample_data.intreview_payments\r\n\r\na couple of errors that were resolved:\r\n  data type int64 to float\r\n  rename tables to: \r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM raw.interview_sample_data.intreview_orders o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as float) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM raw.interview_sample_data.intreview_devices d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM raw.interview_sample_data.intreview_orders as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join raw.interview_sample_data.intreview_addresses oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM raw.interview_sample_data.intreview_payments\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'compiled_sql': "-- import cte's\r\n/*\r\nFirst it is best to pull out your source tables into CTE's\r\nThen we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)\r\n\r\ncte's we found in query:\r\n    raw.interview_sample_data.intreview_orders o\r\n    raw.interview_sample_data.intreview_devices d\r\n    raw.interview_sample_data.intreview_orders as fo -- potentially redunant\r\n    raw.interview_sample_data.intreview_addresses oa \r\n    raw.interview_sample_data.intreview_payments\r\n\r\na couple of errors that were resolved:\r\n  data type int64 to float\r\n  rename tables to: \r\n    \r\n*/\r\n-- logical cte's\r\n-- final cte's\r\n-- select statement\r\n\r\nSELECT\r\n  *,\r\n  amount_total_cents / 100 as amount_total,\r\n  gross_total_amount_cents/ 100 as gross_total_amount,\r\n  total_amount_cents/ 100 as total_amount,\r\n  gross_tax_amount_cents/ 100 as gross_tax_amount,\r\n  gross_amount_cents/ 100 as gross_amount,\r\n  gross_shipping_amount_cents/ 100 as gross_shipping_amount \r\n\r\nFROM (\r\n    \r\n    SELECT\r\n      o.order_id,\r\n      o.user_id,\r\n      o.created_at,\r\n      o.updated_at,\r\n      o.shipped_at,\r\n      o.currency,\r\n      o.status AS order_status,\r\n      CASE\r\n        WHEN o.status IN (\r\n          'paid',\r\n          'completed',\r\n          'shipped'\r\n        ) THEN 'completed'\r\n        ELSE o.status\r\n      END AS order_status_category,\r\n      CASE\r\n        WHEN oa.country_code IS NULL THEN 'Null country'\r\n        WHEN oa.country_code = 'US' THEN 'US'\r\n        WHEN oa.country_code != 'US' THEN 'International'\r\n      END AS country_type,\r\n      o.shipping_method,\r\n      CASE\r\n        WHEN d.device = 'web' THEN 'desktop'\r\n        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'\r\n        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'\r\n        when NULLIF(d.device, '') IS NULL THEN 'unknown'\r\n        ELSE 'ERROR'\r\n      END AS purchase_device_type,\r\n      d.device AS purchase_device,\r\n      CASE\r\n        WHEN fo.first_order_id = o.order_id THEN 'new'\r\n        ELSE 'repeat'\r\n      END AS user_type,\r\n      o.amount_total_cents,\r\n      pa.gross_total_amount_cents,\r\n      CASE\r\n        WHEN o.currency = 'USD' then o.amount_total_cents\r\n        ELSE pa.gross_total_amount_cents\r\n      END AS total_amount_cents,\r\n      pa.gross_tax_amount_cents,\r\n      pa.gross_amount_cents,\r\n      pa.gross_shipping_amount_cents\r\n    FROM raw.interview_sample_data.intreview_orders o\r\n    LEFT JOIN (\r\n        SELECT\r\n          DISTINCT cast(d.type_id as float) as order_id,\r\n          FIRST_VALUE(d.device) OVER (\r\n            PARTITION BY d.type_id\r\n            ORDER BY\r\n              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING\r\n              AND UNBOUNDED FOLLOWING\r\n          ) AS device\r\n        FROM raw.interview_sample_data.intreview_devices d\r\n        WHERE d.type = 'order'\r\n    ) d ON d.order_id = o.order_id\r\n    LEFT JOIN (\r\n        SELECT\r\n          fo.user_id,\r\n          MIN(fo.order_id) as first_order_id\r\n        FROM raw.interview_sample_data.intreview_orders as fo\r\n        WHERE\r\n          fo.status != 'cancelled'\r\n        GROUP BY\r\n          fo.user_id\r\n      ) fo ON o.user_id = fo.user_id\r\n    left join raw.interview_sample_data.intreview_addresses oa \r\n      ON oa.order_id = o.order_id\r\n    LEFT JOIN (\r\n        select\r\n          order_id,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_tax_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n        ) as gross_shipping_amount_cents,\r\n          sum(\r\n            CASE\r\n              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents\r\n              ELSE 0\r\n            END\r\n          ) as gross_total_amount_cents\r\n        FROM raw.interview_sample_data.intreview_payments\r\n        GROUP BY order_id\r\n    ) pa ON pa.order_id = o.order_id\r\n  )\nlimit 500\n/* limit added automatically by dbt cloud */", 'tags': None}, None)
2022-04-21 01:33:26.819548 (Thread-57): handling poll request
2022-04-21 01:33:26.819858 (Thread-57): 01:33:26  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d06c400>]}
2022-04-21 01:33:26.820601 (Thread-57): sending response (<Response 42117 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:37:06.047364 (Thread-58): 01:37:06  Partial parsing enabled: 0 files deleted, 1 files added, 0 files changed.
2022-04-21 01:37:06.049273 (Thread-58): 01:37:06  Partial parsing: added file: my_new_project://models/_archive/test.sql
2022-04-21 01:37:06.053288 (Thread-58): 01:37:06  1699: static parser successfully parsed _archive/test.sql
2022-04-21 01:37:06.096218 (Thread-58): 01:37:06  Sending event: {'category': 'dbt', 'action': 'load_project', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cfb3f70>]}
2022-04-21 01:37:06.889770 (Thread-59): handling status request
2022-04-21 01:37:06.890104 (Thread-59): 01:37:06  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cf9ad00>]}
2022-04-21 01:37:06.890595 (Thread-59): sending response (<Response 1550 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:37:06.929046 (Thread-60): handling status request
2022-04-21 01:37:06.929361 (Thread-60): 01:37:06  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cf9abe0>]}
2022-04-21 01:37:06.929815 (Thread-60): sending response (<Response 1550 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:37:53.670170 (Thread-61): handling status request
2022-04-21 01:37:53.670527 (Thread-61): 01:37:53  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cf9aa90>]}
2022-04-21 01:37:53.671047 (Thread-61): sending response (<Response 1550 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:37:53.993975 (Thread-62): handling run_sql request
2022-04-21 01:37:53.994309 (Thread-62): 01:37:53  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cf9a670>]}
2022-04-21 01:37:56.243784 (Thread-62): sending response (<Response 138 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:37:56.267658 (MainThread): 01:37:56  Sending event: {'category': 'dbt', 'action': 'resource_counts', 'label': 'e14148f2-1cd4-4846-b1a8-10a8cea9b224', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8805c56dc0>]}
2022-04-21 01:37:56.268203 (MainThread): 01:37:56  Found 4 models, 4 tests, 0 snapshots, 0 analyses, 179 macros, 0 operations, 0 seed files, 0 sources, 0 exposures, 0 metrics
2022-04-21 01:37:56.268873 (Thread-1): 01:37:56  Acquiring new snowflake connection "rpc.my_new_project.request"
2022-04-21 01:37:56.269004 (Thread-1): 01:37:56  Began compiling node rpc.my_new_project.request
2022-04-21 01:37:56.269097 (Thread-1): 01:37:56  Compiling rpc.my_new_project.request
2022-04-21 01:37:56.270143 (Thread-1): 01:37:56  finished collecting timing info
2022-04-21 01:37:56.270275 (Thread-1): 01:37:56  Began executing node rpc.my_new_project.request
2022-04-21 01:37:56.270812 (Thread-1): 01:37:56  Using snowflake connection "rpc.my_new_project.request"
2022-04-21 01:37:56.270908 (Thread-1): 01:37:56  On rpc.my_new_project.request: select * from raw.interview_sample_data.interview_orders
limit 500
/* limit added automatically by dbt cloud */
2022-04-21 01:37:56.271020 (Thread-1): 01:37:56  Opening a new connection, currently in state init
2022-04-21 01:37:56.601501 (Thread-63): handling poll request
2022-04-21 01:37:56.601902 (Thread-63): 01:37:56  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d066bb0>]}
2022-04-21 01:37:56.602798 (Thread-63): sending response (<Response 3763 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:37:57.931418 (Thread-64): handling poll request
2022-04-21 01:37:57.931775 (Thread-64): 01:37:57  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d06c250>]}
2022-04-21 01:37:57.932278 (Thread-64): sending response (<Response 386 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:37:58.165255 (Thread-1): 01:37:58  SQL status: SUCCESS 500 in 1.89 seconds
2022-04-21 01:37:58.190293 (Thread-1): 01:37:58  finished collecting timing info
2022-04-21 01:37:58.190674 (Thread-1): 01:37:58  On rpc.my_new_project.request: Close
2022-04-21 01:37:59.248118 (Thread-65): handling poll request
2022-04-21 01:37:59.248470 (Thread-65): 01:37:59  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cf96f70>]}
2022-04-21 01:37:59.251609 (Thread-65): sending response (<Response 62875 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:38:48.030585 (Thread-66): handling status request
2022-04-21 01:38:48.030929 (Thread-66): 01:38:48  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d06ce80>]}
2022-04-21 01:38:48.054242 (Thread-66): sending response (<Response 1550 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:38:48.387586 (Thread-67): handling run_sql request
2022-04-21 01:38:48.387946 (Thread-67): 01:38:48  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3d06ce50>]}
2022-04-21 01:38:50.651110 (Thread-67): sending response (<Response 138 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:38:50.676442 (MainThread): 01:38:50  Sending event: {'category': 'dbt', 'action': 'resource_counts', 'label': '1eb09f38-2567-4efa-9413-1efcfa94c1a5', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7faebeaed760>]}
2022-04-21 01:38:50.676985 (MainThread): 01:38:50  Found 4 models, 4 tests, 0 snapshots, 0 analyses, 179 macros, 0 operations, 0 seed files, 0 sources, 0 exposures, 0 metrics
2022-04-21 01:38:50.677654 (Thread-1): 01:38:50  Acquiring new snowflake connection "rpc.my_new_project.request"
2022-04-21 01:38:50.677789 (Thread-1): 01:38:50  Began compiling node rpc.my_new_project.request
2022-04-21 01:38:50.677880 (Thread-1): 01:38:50  Compiling rpc.my_new_project.request
2022-04-21 01:38:50.679017 (Thread-1): 01:38:50  finished collecting timing info
2022-04-21 01:38:50.679151 (Thread-1): 01:38:50  Began executing node rpc.my_new_project.request
2022-04-21 01:38:50.682729 (Thread-1): 01:38:50  Using snowflake connection "rpc.my_new_project.request"
2022-04-21 01:38:50.682840 (Thread-1): 01:38:50  On rpc.my_new_project.request: -- import cte's
/*
First it is best to pull out your source tables into CTE's
Then we create a _source.yml file in order to source those (which makes a pretty, more inuitive DAG)

cte's we found in query:
    raw.interview_sample_data.interview_orders o
    raw.interview_sample_data.interview_devices d
    raw.interview_sample_data.interview_orders as fo -- potentially redunant
    raw.interview_sample_data.interview_addresses oa 
    raw.interview_sample_data.interview_payments

a couple of errors that were resolved:
  data type int64 to float
  rename tables to: 
    
*/
-- logical cte's
-- final cte's
-- select statement

SELECT
  *,
  amount_total_cents / 100 as amount_total,
  gross_total_amount_cents/ 100 as gross_total_amount,
  total_amount_cents/ 100 as total_amount,
  gross_tax_amount_cents/ 100 as gross_tax_amount,
  gross_amount_cents/ 100 as gross_amount,
  gross_shipping_amount_cents/ 100 as gross_shipping_amount 

FROM (
    
    SELECT
      o.order_id,
      o.user_id,
      o.created_at,
      o.updated_at,
      o.shipped_at,
      o.currency,
      o.status AS order_status,
      CASE
        WHEN o.status IN (
          'paid',
          'completed',
          'shipped'
        ) THEN 'completed'
        ELSE o.status
      END AS order_status_category,
      CASE
        WHEN oa.country_code IS NULL THEN 'Null country'
        WHEN oa.country_code = 'US' THEN 'US'
        WHEN oa.country_code != 'US' THEN 'International'
      END AS country_type,
      o.shipping_method,
      CASE
        WHEN d.device = 'web' THEN 'desktop'
        WHEN d.device IN ('ios-app', 'android-app') THEN 'mobile-app'
        when d.device IN ('mobile', 'tablet') THEN 'mobile-web'
        when NULLIF(d.device, '') IS NULL THEN 'unknown'
        ELSE 'ERROR'
      END AS purchase_device_type,
      d.device AS purchase_device,
      CASE
        WHEN fo.first_order_id = o.order_id THEN 'new'
        ELSE 'repeat'
      END AS user_type,
      o.amount_total_cents,
      pa.gross_total_amount_cents,
      CASE
        WHEN o.currency = 'USD' then o.amount_total_cents
        ELSE pa.gross_total_amount_cents
      END AS total_amount_cents,
      pa.gross_tax_amount_cents,
      pa.gross_amount_cents,
      pa.gross_shipping_amount_cents
    FROM raw.interview_sample_data.interview_orders o
    LEFT JOIN (
        SELECT
          DISTINCT cast(d.type_id as float) as order_id,
          FIRST_VALUE(d.device) OVER (
            PARTITION BY d.type_id
            ORDER BY
              d.created_at ROWS BETWEEN UNBOUNDED PRECEDING
              AND UNBOUNDED FOLLOWING
          ) AS device
        FROM raw.interview_sample_data.interview_devices d
        WHERE d.type = 'order'
    ) d ON d.order_id = o.order_id
    LEFT JOIN (
        SELECT
          fo.user_id,
          MIN(fo.order_id) as first_order_id
        FROM raw.interview_sample_data.interview_orders as fo
        WHERE
          fo.status != 'cancelled'
        GROUP BY
          fo.user_id
      ) fo ON o.user_id = fo.user_id
    left join raw.interview_sample_data.interview_addresses oa 
      ON oa.order_id = o.order_id
    LEFT JOIN (
        select
          order_id,
          sum(
            CASE
              WHEN status = 'completed' THEN tax_amount_cents
              ELSE 0
            END
          ) as gross_tax_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN amount_cents
              ELSE 0
            END
          ) as gross_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN amount_shipping_cents
              ELSE 0
            END
        ) as gross_shipping_amount_cents,
          sum(
            CASE
              WHEN status = 'completed' THEN tax_amount_cents + amount_cents + amount_shipping_cents
              ELSE 0
            END
          ) as gross_total_amount_cents
        FROM raw.interview_sample_data.interview_payments
        GROUP BY order_id
    ) pa ON pa.order_id = o.order_id
  )
limit 500
/* limit added automatically by dbt cloud */
2022-04-21 01:38:50.682923 (Thread-1): 01:38:50  Opening a new connection, currently in state init
2022-04-21 01:38:50.990797 (Thread-68): handling poll request
2022-04-21 01:38:50.991228 (Thread-68): 01:38:50  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cfb0160>]}
2022-04-21 01:38:50.992144 (Thread-68): sending response (<Response 8139 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:38:52.334602 (Thread-69): handling poll request
2022-04-21 01:38:52.334932 (Thread-69): 01:38:52  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cfb00d0>]}
2022-04-21 01:38:52.335449 (Thread-69): sending response (<Response 395 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:38:53.123405 (Thread-1): 01:38:53  SQL status: SUCCESS 500 in 2.44 seconds
2022-04-21 01:38:53.657283 (Thread-70): handling poll request
2022-04-21 01:38:53.658000 (Thread-70): 01:38:53  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cfb0550>]}
2022-04-21 01:38:53.658700 (Thread-70): sending response (<Response 1094 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:38:53.655991 (Thread-1): 01:38:53  finished collecting timing info
2022-04-21 01:38:53.656266 (Thread-1): 01:38:53  On rpc.my_new_project.request: Close
2022-04-21 01:38:55.001138 (Thread-71): handling poll request
2022-04-21 01:38:55.001484 (Thread-71): 01:38:55  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3f0ebaf0>]}
2022-04-21 01:38:55.010705 (Thread-71): sending response (<Response 149494 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:45:59.850439 (Thread-72): 01:45:59  Partial parsing enabled: 0 files deleted, 0 files added, 0 files changed.
2022-04-21 01:45:59.852126 (Thread-72): 01:45:59  Partial parsing enabled, no changes found, skipping parsing
2022-04-21 01:45:59.857139 (Thread-72): 01:45:59  Sending event: {'category': 'dbt', 'action': 'load_project', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cd1f850>]}
2022-04-21 01:46:00.729968 (Thread-73): handling status request
2022-04-21 01:46:00.730295 (Thread-73): 01:46:00  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3ce135b0>]}
2022-04-21 01:46:00.730794 (Thread-73): sending response (<Response 1241 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:46:00.863050 (Thread-74): handling status request
2022-04-21 01:46:00.863320 (Thread-74): 01:46:00  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3ce133a0>]}
2022-04-21 01:46:00.863742 (Thread-74): sending response (<Response 1241 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:46:10.210707 (Thread-75): 01:46:10  Partial parsing enabled: 0 files deleted, 1 files added, 0 files changed.
2022-04-21 01:46:10.211044 (Thread-75): 01:46:10  Partial parsing: added file: my_new_project://models/_archive/stg_query.sql
2022-04-21 01:46:10.214643 (Thread-75): 01:46:10  1699: static parser successfully parsed _archive/stg_query.sql
2022-04-21 01:46:10.261751 (Thread-75): 01:46:10  Sending event: {'category': 'dbt', 'action': 'load_project', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3ccb5730>]}
2022-04-21 01:46:10.888639 (Thread-76): handling status request
2022-04-21 01:46:10.888960 (Thread-76): 01:46:10  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cd06c70>]}
2022-04-21 01:46:10.889424 (Thread-76): sending response (<Response 1560 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:46:10.937278 (Thread-77): handling status request
2022-04-21 01:46:10.937489 (Thread-77): 01:46:10  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cd06a90>]}
2022-04-21 01:46:10.937837 (Thread-77): sending response (<Response 1560 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:47:57.952546 (Thread-78): 01:47:57  Partial parsing enabled: 0 files deleted, 0 files added, 1 files changed.
2022-04-21 01:47:57.953382 (Thread-78): 01:47:57  Partial parsing: updated file: my_new_project://models/_archive/orginal_query.sql
2022-04-21 01:47:57.957067 (Thread-78): 01:47:57  1699: static parser successfully parsed _archive/orginal_query.sql
2022-04-21 01:47:58.002051 (Thread-78): 01:47:58  Sending event: {'category': 'dbt', 'action': 'load_project', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cc973a0>]}
2022-04-21 01:47:58.792011 (Thread-79): handling status request
2022-04-21 01:47:58.792344 (Thread-79): 01:47:58  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cc88880>]}
2022-04-21 01:47:58.792829 (Thread-79): sending response (<Response 1570 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:47:58.849951 (Thread-80): handling status request
2022-04-21 01:47:58.851999 (Thread-80): 01:47:58  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cc886a0>]}
2022-04-21 01:47:58.852487 (Thread-80): sending response (<Response 1570 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:48:00.735752 (Thread-81): 01:48:00  Partial parsing enabled: 0 files deleted, 0 files added, 1 files changed.
2022-04-21 01:48:00.736099 (Thread-81): 01:48:00  Partial parsing: updated file: my_new_project://models/_archive/stg_query.sql
2022-04-21 01:48:00.870934 (Thread-81): 01:48:00  1699: static parser successfully parsed _archive/stg_query.sql
2022-04-21 01:48:00.910117 (Thread-81): 01:48:00  Sending event: {'category': 'dbt', 'action': 'load_project', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c6e307070>]}
2022-04-21 01:48:01.526018 (Thread-82): handling status request
2022-04-21 01:48:01.526371 (Thread-82): 01:48:01  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cc6f820>]}
2022-04-21 01:48:01.526860 (Thread-82): sending response (<Response 1562 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:48:01.662502 (Thread-83): handling status request
2022-04-21 01:48:01.662845 (Thread-83): 01:48:01  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cc6f640>]}
2022-04-21 01:48:01.663351 (Thread-83): sending response (<Response 1562 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:48:06.162436 (Thread-84): 01:48:06  Partial parsing enabled: 0 files deleted, 0 files added, 1 files changed.
2022-04-21 01:48:06.162789 (Thread-84): 01:48:06  Partial parsing: updated file: my_new_project://models/_archive/test.sql
2022-04-21 01:48:06.166280 (Thread-84): 01:48:06  1699: static parser successfully parsed _archive/test.sql
2022-04-21 01:48:06.209110 (Thread-84): 01:48:06  Sending event: {'category': 'dbt', 'action': 'load_project', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c6e3756a0>]}
2022-04-21 01:48:06.879416 (Thread-85): handling status request
2022-04-21 01:48:06.879761 (Thread-85): 01:48:06  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cfa7070>]}
2022-04-21 01:48:06.880254 (Thread-85): sending response (<Response 1552 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:48:06.883265 (Thread-86): handling status request
2022-04-21 01:48:06.883478 (Thread-86): 01:48:06  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cfa7460>]}
2022-04-21 01:48:06.883831 (Thread-86): sending response (<Response 1552 bytes [200 OK]>) to 10.0.26.132
2022-04-21 01:48:44.504513 (Thread-87): handling status request
2022-04-21 01:48:44.504849 (Thread-87): 01:48:44  Sending event: {'category': 'dbt', 'action': 'rpc_request', 'label': 'e198575e-6fe8-469d-99f7-f2625cd635f1', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f6c3cfa7850>]}
2022-04-21 01:48:44.505318 (Thread-87): sending response (<Response 1552 bytes [200 OK]>) to 10.0.26.132
